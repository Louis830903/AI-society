# 数据流设计

<cite>
**本文档引用的文件**
- [backend/app/core/world.py](file://backend/app/core/world.py)
- [backend/app/core/agent.py](file://backend/app/core/agent.py)
- [backend/app/core/config.py](file://backend/app/core/config.py)
- [specs/01-architecture.spec.md](file://specs/01-architecture.spec.md)
- [specs/03-economy-system.spec.md](file://specs/03-economy-system.spec.md)
- [specs/04-conversation-system.spec.md](file://specs/04-conversation-system.spec.md)
- [specs/05-world-map.spec.md](file://specs/05-world-map.spec.md)
- [specs/06-api-design.spec.md](file://specs/06-api-design.spec.md)
- [specs/08-implementation-plan.spec.md](file://specs/08-implementation-plan.spec.md)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构概览](#架构概览)
5. [详细组件分析](#详细组件分析)
6. [依赖分析](#依赖分析)
7. [性能考虑](#性能考虑)
8. [故障排除指南](#故障排除指南)
9. [结论](#结论)

## 简介

AI Society是一个基于时间推进的世界模拟系统，通过智能体驱动的AI决策实现复杂的社交互动和经济活动。本项目采用异步架构设计，实现了完整的数据流管道，包括世界循环主流程和LLM调用流程。

系统的核心特点是：
- **时间推进机制**：现实1分钟 = 游戏内10分钟的时间缩放
- **智能体自治**：每个智能体都是独立的决策实体
- **实时交互**：通过WebSocket实现前后端实时数据同步
- **多模型支持**：支持DeepSeek、OpenAI等多种LLM提供商

## 项目结构

项目采用分层架构设计，主要分为以下层次：

```mermaid
graph TB
subgraph "表现层"
Frontend[React前端]
WebSocket[WebSocket连接]
end
subgraph "API层"
FastAPI[FastAPI应用]
Routes[路由层]
Services[业务服务]
end
subgraph "核心引擎层"
WorldEngine[世界引擎]
AgentEngine[智能体引擎]
EventBus[事件总线]
end
subgraph "LLM抽象层"
LLMRouter[LLM路由器]
DeepSeekAdapter[DeepSeek适配器]
OpenAIAdapter[OpenAI适配器]
end
subgraph "数据持久层"
PostgreSQL[PostgreSQL]
Qdrant[Qdrant向量库]
Redis[Redis缓存]
end
Frontend --> WebSocket
WebSocket --> FastAPI
FastAPI --> Routes
FastAPI --> Services
Services --> WorldEngine
Services --> AgentEngine
WorldEngine --> EventBus
AgentEngine --> EventBus
EventBus --> LLMRouter
LLMRouter --> DeepSeekAdapter
LLMRouter --> OpenAIAdapter
LLMRouter --> Qdrant
WorldEngine --> PostgreSQL
AgentEngine --> Redis
```

**图表来源**
- [specs/01-architecture.spec.md](file://specs/01-architecture.spec.md#L1-L255)

**章节来源**
- [specs/01-architecture.spec.md](file://specs/01-architecture.spec.md#L1-L255)

## 核心组件

### 世界时钟系统

世界时钟是整个系统的时间基准，实现了现实时间与游戏内时间的转换：

```mermaid
classDiagram
class WorldClock {
+datetime start_real_time
+datetime start_world_time
+int time_scale
+now() datetime
}
class WorldConfig {
+int width
+int height
}
class WorldState {
+WorldClock clock
+WorldConfig config
+Dict~str, AgentState~ agents
}
WorldState --> WorldClock : "包含"
WorldState --> WorldConfig : "包含"
```

**图表来源**
- [backend/app/core/world.py](file://backend/app/core/world.py#L8-L40)

### 智能体数据模型

智能体是系统的基本单元，包含完整的个人信息、状态和行为能力：

```mermaid
classDiagram
class AgentState {
+string id
+string name
+int age
+Gender gender
+Occupation occupation
+Personality personality
+Dict~str, int~ skills
+string life_goal
+float x
+float y
+Needs needs
+Economy economy
+string current_action
+string current_thinking
+string current_emotion
+str[] recent_memory_ids
+string model_name
}
class AgentDecision {
+string action
+string target
+string reason
+string thinking
}
class AgentContext {
+datetime world_time
+string location_name
+str[] nearby_agent_summaries
+str[] recent_memories
}
class Personality {
+int openness
+int conscientiousness
+int extraversion
+int agreeableness
+int neuroticism
}
class Needs {
+int energy
+int social
}
class Economy {
+float money
+float income_per_hour
+float base_daily_cost
}
AgentState --> Personality : "包含"
AgentState --> Needs : "包含"
AgentState --> Economy : "包含"
```

**图表来源**
- [backend/app/core/agent.py](file://backend/app/core/agent.py#L25-L92)

**章节来源**
- [backend/app/core/world.py](file://backend/app/core/world.py#L1-L40)
- [backend/app/core/agent.py](file://backend/app/core/agent.py#L1-L92)

## 架构概览

系统采用分层架构，每层都有明确的职责分工：

### 世界循环主流程

系统每游戏内10分钟执行一次完整的更新周期：

```mermaid
sequenceDiagram
participant Scheduler as "调度器"
participant WorldEngine as "世界引擎"
participant AgentEngine as "智能体引擎"
participant EventBus as "事件总线"
participant Frontend as "前端客户端"
Scheduler->>WorldEngine : "时间推进"
WorldEngine->>WorldEngine : "更新世界时钟"
WorldEngine->>WorldEngine : "触发定时事件"
par "并行处理智能体"
WorldEngine->>AgentEngine : "需求衰减"
WorldEngine->>AgentEngine : "经济结算"
WorldEngine->>AgentEngine : "行为决策"
end
AgentEngine->>AgentEngine : "社交互动检测"
AgentEngine->>EventBus : "发布事件"
EventBus->>Frontend : "WebSocket推送"
Frontend->>Frontend : "实时界面更新"
```

**图表来源**
- [specs/01-architecture.spec.md](file://specs/01-architecture.spec.md#L180-L203)

### LLM调用流程

智能体决策时的完整LLM调用链路：

```mermaid
sequenceDiagram
participant AgentEngine as "智能体引擎"
participant AgentContext as "AgentContext"
participant LLMRouter as "LLM路由器"
participant Adapter as "LLM适配器"
participant Model as "外部模型"
participant Memory as "记忆系统"
participant EventBus as "事件总线"
AgentEngine->>AgentEngine : "收集环境信息"
AgentEngine->>AgentContext : "组装上下文"
AgentEngine->>LLMRouter : "请求决策"
LLMRouter->>Adapter : "路由到具体模型"
Adapter->>Model : "发送请求"
Model-->>Adapter : "返回响应"
Adapter-->>LLMRouter : "解析结果"
LLMRouter-->>AgentEngine : "决策结果"
AgentEngine->>AgentEngine : "验证合法性"
AgentEngine->>Memory : "更新记忆"
AgentEngine->>EventBus : "广播事件"
```

**图表来源**
- [specs/01-architecture.spec.md](file://specs/01-architecture.spec.md#L205-L227)

**章节来源**
- [specs/01-architecture.spec.md](file://specs/01-architecture.spec.md#L178-L227)

## 详细组件分析

### 世界循环详细流程

#### 时间推进机制

世界循环以游戏内10分钟为单位执行，对应现实1分钟：

```mermaid
flowchart TD
Start([开始新周期]) --> UpdateClock["更新世界时钟<br/>计算当前游戏时间"]
UpdateClock --> TriggerEvents["触发定时事件<br/>日出/日落/发工资等"]
TriggerEvents --> ParallelAgents["并行处理所有智能体<br/>需求衰减 + 经济结算"]
ParallelAgents --> DecisionMaking["智能体决策<br/>简单决策 + 复杂决策"]
DecisionMaking --> SocialInteraction["社交互动<br/>近距离检测 + 对话触发"]
SocialInteraction --> BroadcastEvents["事件广播<br/>WebSocket推送"]
BroadcastEvents --> UpdateFrontend["前端实时更新<br/>地图/面板数据"]
UpdateFrontend --> End([周期结束])
```

**图表来源**
- [specs/01-architecture.spec.md](file://specs/01-architecture.spec.md#L180-L203)

#### 智能体更新流程

每个智能体的更新包含多个子过程：

```mermaid
flowchart TD
AgentStart([智能体更新开始]) --> NeedDecay["需求衰减<br/>能量-5，社交-3"]
NeedDecay --> EconomySettlement["经济结算<br/>收入/支出处理"]
EconomySettlement --> SimpleDecision{"简单决策可用？"}
SimpleDecision --> |是| SimplePath["规则引擎决策<br/>如去咖啡馆"]
SimpleDecision --> |否| ComplexDecision["复杂决策<br/>调用LLM"]
SimplePath --> ActionExecution["执行行为<br/>移动/交互"]
ComplexDecision --> ActionExecution
ActionExecution --> SocialDetection["社交检测<br/>附近智能体识别"]
SocialDetection --> End([智能体更新完成])
```

**图表来源**
- [specs/01-architecture.spec.md](file://specs/01-architecture.spec.md#L189-L194)

### LLM调用系统

#### 上下文构建

AgentContext负责收集和组织决策所需的全部信息：

| 字段名称 | 类型 | 描述 | 示例 |
|---------|------|------|------|
| world_time | datetime | 当前游戏时间 | 2024-01-15 14:30:00 |
| location_name | string | 当前位置名称 | "时光咖啡馆" |
| nearby_agent_summaries | List[string] | 附近智能体简述 | ["程序员李明", "设计师王芳"] |
| recent_memories | List[string] | 最近记忆片段 | ["昨天的会议讨论"] |

#### 模型路由机制

LLMRouter根据智能体配置选择合适的模型：

```mermaid
classDiagram
class LLMRouter {
+Dict~str, LLMAdapter~ adapters
+register(name, adapter)
+generate(model_name, prompt) str
}
class LLMAdapter {
<<interface>>
+generate(prompt) str
}
class DeepSeekAdapter {
+generate(prompt) str
+client AsyncOpenAI
}
class OpenAIAdapter {
+generate(prompt) str
+client OpenAI
}
LLMRouter --> LLMAdapter : "管理多个适配器"
DeepSeekAdapter ..|> LLMAdapter
OpenAIAdapter ..|> LLMAdapter
```

**图表来源**
- [specs/08-implementation-plan.spec.md](file://specs/08-implementation-plan.spec.md#L115-L137)

#### 响应解析与决策执行

LLM响应的标准化处理流程：

```mermaid
flowchart TD
LLMResponse["LLM响应"] --> ParseResponse["解析响应<br/>提取动作/目标/原因"]
ParseResponse --> ValidateAction{"验证动作合法性"}
ValidateAction --> |合法| ExecuteAction["执行决策<br/>更新智能体状态"]
ValidateAction --> |非法| RetryDecision["重试决策<br/>调整提示词"]
ExecuteAction --> UpdateMemory["更新记忆系统<br/>存储决策过程"]
UpdateMemory --> BroadcastEvent["广播事件<br/>通知所有订阅者"]
RetryDecision --> LLMResponse
BroadcastEvent --> End([流程结束])
```

**图表来源**
- [specs/01-architecture.spec.md](file://specs/01-architecture.spec.md#L219-L226)

**章节来源**
- [specs/04-conversation-system.spec.md](file://specs/04-conversation-system.spec.md#L190-L240)
- [specs/08-implementation-plan.spec.md](file://specs/08-implementation-plan.spec.md#L115-L137)

### 经济系统数据流

经济系统的数据在多个层面流转：

```mermaid
graph LR
subgraph "经济事件"
Income[收入事件]
Expense[支出事件]
PassiveIncome[被动收入]
end
subgraph "经济状态"
DailySettlement[每日结算]
EconomicStatus[经济状态]
BehaviorModifiers[行为修饰]
end
subgraph "数据库存储"
Transactions[交易记录表]
Debts[债务关系表]
end
Income --> DailySettlement
Expense --> DailySettlement
PassiveIncome --> DailySettlement
DailySettlement --> EconomicStatus
EconomicStatus --> BehaviorModifiers
BehaviorModifiers --> AgentActions[智能体行为]
DailySettlement --> Transactions
EconomicStatus --> Debts
```

**图表来源**
- [specs/03-economy-system.spec.md](file://specs/03-economy-system.spec.md#L90-L156)

**章节来源**
- [specs/03-economy-system.spec.md](file://specs/03-economy-system.spec.md#L1-L418)

### 对话系统数据流

对话系统的完整数据流：

```mermaid
sequenceDiagram
participant AgentA as "智能体A"
participant AgentB as "智能体B"
participant Conversation as "对话管理"
participant LLMRouter as "LLM路由器"
participant Memory as "记忆系统"
participant EventBus as "事件总线"
AgentA->>Conversation : "检测到对话机会"
AgentB->>Conversation : "接受对话邀请"
Conversation->>LLMRouter : "生成开场白"
LLMRouter-->>Conversation : "返回开场白"
Conversation->>EventBus : "发布对话开始事件"
loop "对话轮次"
Conversation->>LLMRouter : "生成回复"
LLMRouter-->>Conversation : "返回回复"
Conversation->>EventBus : "发布消息事件"
Conversation->>Memory : "更新对话记忆"
end
Conversation->>EventBus : "发布对话结束事件"
Conversation->>Memory : "存储对话摘要"
```

**图表来源**
- [specs/04-conversation-system.spec.md](file://specs/04-conversation-system.spec.md#L190-L240)

**章节来源**
- [specs/04-conversation-system.spec.md](file://specs/04-conversation-system.spec.md#L1-L581)

## 依赖分析

系统采用松耦合设计，各组件间通过清晰的接口交互：

```mermaid
graph TB
subgraph "核心依赖"
WorldEngine[世界引擎] --> AgentEngine[智能体引擎]
AgentEngine --> EventBus[事件总线]
EventBus --> WebSocket[WebSocket服务]
end
subgraph "LLM依赖"
AgentEngine --> LLMRouter[LLM路由器]
LLMRouter --> DeepSeekAdapter[DeepSeek适配器]
LLMRouter --> OpenAIAdapter[OpenAI适配器]
DeepSeekAdapter --> DeepSeekAPI[DeepSeek API]
OpenAIAdapter --> OpenAIAPI[OpenAI API]
end
subgraph "数据存储依赖"
WorldEngine --> PostgreSQL[PostgreSQL]
AgentEngine --> Redis[Redis]
LLMRouter --> Qdrant[Qdrant]
end
subgraph "配置依赖"
Config[配置管理] --> WorldEngine
Config --> AgentEngine
Config --> LLMRouter
end
```

**图表来源**
- [specs/01-architecture.spec.md](file://specs/01-architecture.spec.md#L1-L255)
- [backend/app/core/config.py](file://backend/app/core/config.py#L1-L42)

**章节来源**
- [backend/app/core/config.py](file://backend/app/core/config.py#L1-L42)

## 性能考虑

### 异步处理策略

系统广泛采用异步编程模式：

- **并行智能体处理**：使用asyncio实现多个智能体的并发更新
- **异步WebSocket**：支持大量客户端的实时数据推送
- **非阻塞IO操作**：数据库和外部API调用采用异步模式
- **事件驱动架构**：通过事件总线实现解耦的数据传递

### 数据一致性保证

系统通过多种机制确保数据一致性：

- **原子性操作**：关键业务操作使用数据库事务
- **最终一致性**：通过事件总线实现跨组件的数据同步
- **版本控制**：智能体状态包含last_updated时间戳
- **冲突解决**：并发更新时采用最后写入获胜策略

### 性能优化建议

1. **缓存策略**
   - Redis缓存热点数据
   - LRU缓存最近使用的LLM响应
   - 地图瓦片缓存

2. **批处理优化**
   - 批量更新智能体状态
   - 批量推送WebSocket事件
   - 批量写入数据库

3. **资源池管理**
   - LLM客户端连接池
   - 数据库连接池
   - 线程池管理CPU密集型任务

## 故障排除指南

### 常见错误类型

| 错误类型 | 触发条件 | 处理策略 |
|---------|---------|---------|
| LLM调用失败 | API超时/认证失败 | 重试机制 + 降级策略 |
| 数据库连接异常 | 连接池耗尽 | 连接池监控 + 自动恢复 |
| WebSocket断开 | 网络波动 | 自动重连 + 事件重放 |
| 智能体状态冲突 | 并发更新冲突 | 版本检查 + 冲突解决 |

### 错误处理流程

```mermaid
flowchart TD
ErrorOccurred["错误发生"] --> IdentifyError["识别错误类型"]
IdentifyError --> CheckRetry{"可重试错误？"}
CheckRetry --> |是| RetryOperation["执行重试"]
CheckRetry --> |否| LogError["记录错误日志"]
RetryOperation --> RetrySuccess{"重试成功？"}
RetrySuccess --> |是| ContinueProcess["继续正常流程"]
RetrySuccess --> |否| ApplyFallback["应用降级策略"]
ApplyFallback --> LogError
LogError --> NotifyAdmin["通知管理员"]
ContinueProcess --> End([流程结束])
NotifyAdmin --> End
```

**章节来源**
- [specs/06-api-design.spec.md](file://specs/06-api-design.spec.md#L619-L634)

## 结论

AI Society项目通过精心设计的数据流架构，实现了复杂世界的实时模拟。系统的关键优势包括：

1. **清晰的分层架构**：从表现层到数据持久层的完整分层设计
2. **高效的异步处理**：充分利用异步编程提升系统吞吐量
3. **灵活的LLM集成**：支持多模型提供商的统一抽象
4. **强大的事件驱动**：通过事件总线实现组件间的松耦合交互
5. **完善的性能优化**：从缓存策略到批处理优化的全方位考虑

该架构为AI Society项目提供了坚实的技术基础，能够支持大规模智能体的并发运行和实时交互，为用户创造沉浸式的AI世界体验。